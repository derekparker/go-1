commit 654c7e1cc762d05713a38ebd167a1cb93759b470
Author: Derek Parker <parkerderek86@gmail.com>
Date:   Wed Dec 6 11:31:12 2023 -0800

    Initialize the opensslv2 module

diff --git a/api/go1.16.txt b/api/go1.16.txt
index e12a050939..e555bfdf5c 100644
--- a/api/go1.16.txt
+++ b/api/go1.16.txt
@@ -8525,3 +8525,5 @@ pkg syscall (darwin-arm64-cgo), type WaitStatus uint32
 pkg syscall (darwin-arm64-cgo), var Stderr int
 pkg syscall (darwin-arm64-cgo), var Stdin int
 pkg syscall (darwin-arm64-cgo), var Stdout int
+pkg crypto/rsa, func GenerateKeyNotBoring(io.Reader, int) (*PrivateKey, error)
+pkg crypto/rsa, func GenerateMultiPrimeKeyNotBoring(io.Reader, int, int) (*PrivateKey, error)
diff --git a/src/crypto/internal/backend/nobackend.go b/src/crypto/internal/backend/nobackend.go
index ac90ba299f..88be5de522 100644
--- a/src/crypto/internal/backend/nobackend.go
+++ b/src/crypto/internal/backend/nobackend.go
@@ -10,15 +10,15 @@ package backend
 import (
 	"crypto"
 	"crypto/cipher"
-	"crypto/internal/boring/sig"
-	"math/big"
 	bbig "crypto/internal/boring"
+	"crypto/internal/boring/sig"
 	"hash"
 	"io"
+	"math/big"
 )
 
 func init() {
-       strictFIPSNonCompliantBinaryCheck()
+	strictFIPSNonCompliantBinaryCheck()
 }
 
 var enabled = false
@@ -32,6 +32,10 @@ func Unreachable() {
 	sig.StandardCrypto()
 }
 
+func IsStrictFIPSMode() bool {
+	return false
+}
+
 // UnreachableExceptTests marks code that should be unreachable
 // when BoringCrypto is in use. It is a no-op without BoringCrypto.
 func UnreachableExceptTests() {}
diff --git a/src/crypto/internal/backend/not_strict_fips.go b/src/crypto/internal/backend/not_strict_fips.go
index f8e8fd6869..806b035aa8 100644
--- a/src/crypto/internal/backend/not_strict_fips.go
+++ b/src/crypto/internal/backend/not_strict_fips.go
@@ -3,6 +3,8 @@
 
 package backend
 
+var isStrictFIPS bool = false
+
 func strictFIPSOpenSSLRuntimeCheck() {
 }
 
diff --git a/src/crypto/internal/backend/openssl.go b/src/crypto/internal/backend/openssl.go
index 49bb6da477..5271677e8b 100644
--- a/src/crypto/internal/backend/openssl.go
+++ b/src/crypto/internal/backend/openssl.go
@@ -11,16 +11,75 @@
 package backend
 
 import (
+	"crypto/internal/boring/sig"
+	"fmt"
 	"os"
+	"syscall"
+
 	"github.com/golang-fips/openssl/v2"
 )
 
 // Enabled controls whether FIPS crypto is enabled.
 var enabled bool
 
+var knownVersions = [...]string{"3", "1.1", "11", "111", "1.0.2", "1.0.0", "10"}
+
 func init() {
-	strictFIPSOpenSSLRuntimeCheck()
-	enabled = openssl.FIPS()
+	version, _ := syscall.Getenv("GO_OPENSSL_VERSION_OVERRIDE")
+	if version == "" {
+		var fallbackVersion string
+		for _, v := range knownVersions {
+			vv := fmt.Sprintf("libcrypto.so.%s", v)
+			exists, fips := openssl.CheckVersion(vv)
+			if exists && fips {
+				version = vv
+				break
+			}
+			if exists && fallbackVersion == "" {
+				fallbackVersion = vv
+			}
+		}
+		if version == "" && fallbackVersion != "" {
+			version = fallbackVersion
+		}
+	}
+	if version == "" {
+		strictFIPSOpenSSLRuntimeCheck()
+		return
+	}
+	if err := openssl.Init(version); err != nil {
+		panic("opensslcrypto: can't initialize OpenSSL " + version + ": " + err.Error())
+	}
+	// 0: FIPS opt-out: abort the process if it is enabled and can't be disabled.
+	// 1: FIPS required: abort the process if it is not enabled and can't be enabled.
+	// other values: do not override OpenSSL configured FIPS mode.
+	var fips string
+	if v, ok := syscall.Getenv("GOLANG_FIPS"); ok {
+		fips = v
+	} else if hostFIPSModeEnabled() {
+		// System configuration can only force FIPS mode.
+		fips = "1"
+	}
+	switch fips {
+	case "0":
+		if openssl.FIPS() {
+			if err := openssl.SetFIPS(false); err != nil {
+				panic("opensslcrypto: can't disable FIPS mode for " + openssl.VersionText() + ": " + err.Error())
+			}
+		}
+	case "1":
+		if !openssl.FIPS() {
+			if err := openssl.SetFIPS(true); err != nil {
+				panic("opensslcrypto: can't enable FIPS mode for " + openssl.VersionText() + ": " + err.Error())
+			}
+		}
+		enabled = true
+	}
+	sig.BoringCrypto()
+}
+
+func IsStrictFIPSMode() bool {
+	return isStrictFIPS
 }
 
 func Enabled() bool {
@@ -61,8 +120,6 @@ func UnreachableExceptTests() {
 	}
 }
 
-
-
 const RandReader = openssl.RandReader
 
 var NewGCMTLS = openssl.NewGCMTLS
diff --git a/src/crypto/internal/backend/strict_fips.go b/src/crypto/internal/backend/strict_fips.go
index 894eeca942..c1bda67f12 100644
--- a/src/crypto/internal/backend/strict_fips.go
+++ b/src/crypto/internal/backend/strict_fips.go
@@ -8,6 +8,8 @@ import (
 	"os"
 )
 
+var isStrictFIPS bool = true
+
 func strictFIPSOpenSSLRuntimeCheck() {
 	if hostFIPSModeEnabled() && !Enabled() {
 		fmt.Fprintln(os.Stderr, "FIPS mode is enabled, but the required OpenSSL backend is unavailable")
diff --git a/src/crypto/rsa/boring_test.go b/src/crypto/rsa/boring_test.go
index 4e7fd9de4a..bd060c6a9d 100644
--- a/src/crypto/rsa/boring_test.go
+++ b/src/crypto/rsa/boring_test.go
@@ -22,7 +22,7 @@ import (
 )
 
 func TestBoringASN1Marshal(t *testing.T) {
-	k, err := GenerateKey(rand.Reader, 128)
+	k, err := GenerateKey(rand.Reader, 3072)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/src/crypto/rsa/equal_test.go b/src/crypto/rsa/equal_test.go
index 90f4bf9475..688df68545 100644
--- a/src/crypto/rsa/equal_test.go
+++ b/src/crypto/rsa/equal_test.go
@@ -13,7 +13,7 @@ import (
 )
 
 func TestEqual(t *testing.T) {
-	private, _ := rsa.GenerateKey(rand.Reader, 512)
+	private, _ := rsa.GenerateKey(rand.Reader, 2048)
 	public := &private.PublicKey
 
 	if !public.Equal(public) {
@@ -41,7 +41,7 @@ func TestEqual(t *testing.T) {
 		t.Errorf("private key is not equal to itself after decoding: %v", private)
 	}
 
-	other, _ := rsa.GenerateKey(rand.Reader, 512)
+	other, _ := rsa.GenerateKey(rand.Reader, 2048)
 	if public.Equal(other.Public()) {
 		t.Errorf("different public keys are Equal")
 	}
diff --git a/src/crypto/rsa/pkcs1v15_test.go b/src/crypto/rsa/pkcs1v15_test.go
index 0853178e3a..3db1e94fff 100644
--- a/src/crypto/rsa/pkcs1v15_test.go
+++ b/src/crypto/rsa/pkcs1v15_test.go
@@ -11,7 +11,6 @@ import (
 	"crypto/internal/backend/boringtest"
 	"crypto/rand"
 	. "crypto/rsa"
-	"crypto/sha1"
 	"crypto/sha256"
 	"crypto/x509"
 	"encoding/base64"
@@ -210,16 +209,16 @@ type signPKCS1v15Test struct {
 //
 //	`openssl rsautl -verify -inkey pk -in signature | hexdump -C`
 var signPKCS1v15Tests = []signPKCS1v15Test{
-	{"Test.\n", "0c7c85d938862248846cba06b06ac9bfe752aafed3092c224f257855006aa35b43d101e6c8e59cbc4c20b07c81552963f189dea700e042d4b70c236a031a29a9273cc138e69dc1a5834491de4822d8cb6acf218789d2586cb0f3892236b0948ffaf8691f6fa04597caa45068f9be39b8ea8b5336a8c94e2696f872120778abcfea711e5fbf75f835f0f5204ccdd020013c2ceae25e9d1378a1d10cf86ca269eef48fee8ebb5e8dfb08f0c48d22d1a7162e080ec1f6e48541288aaaa1f2370f0688cf1786a32abed41df1d3b96b665794bf7a772743fc8b62d73901cea4569494c794a01ccc7dda0d42199f5b58739c0c0e280774b56ccf51993f5ea3d4954319"},
+	{"Test.\n", "0c7da2fe34372c9e433ca668b6edf4cd7f7eb29f11c11c44d99cb6dc6fe4344cc656075015de6d0249d25b6e01bf22276e9f97f6e64f5905ce96cfc69e3c30e3813eb80553b1e53993482b97c920d030e1daf6c5f11f532a166a4b4aea34c6f8ed5579ccf6bfd5e20250d1979e97c358363da8ae15a095f07e9c54bfb948a94a75a6c8a0cbe4b9970d780ddf49369b2f134915e9a8ccf20e7b07981d0b95978630ee754f20bad163cdcff8c56c9bc66fd1060961779f1554894597086477d15346955d1a1c67d9718c4d25d840cf83fe203fd4e5681fc388a0395b79b94b1ade281f3682fb08a02ed6fa209caf489e9ccf501a86e99a36737b241c1e8ab2c2a4"},
 }
 
 func TestSignPKCS1v15(t *testing.T) {
 	for i, test := range signPKCS1v15Tests {
-		h := sha1.New()
+		h := sha256.New()
 		h.Write([]byte(test.in))
 		digest := h.Sum(nil)
 
-		s, err := SignPKCS1v15(nil, boringRsaPrivateKey, crypto.SHA1, digest)
+		s, err := SignPKCS1v15(nil, boringRsaPrivateKey, crypto.SHA256, digest)
 		if err != nil {
 			t.Errorf("#%d %s", i, err)
 		}
@@ -233,13 +232,13 @@ func TestSignPKCS1v15(t *testing.T) {
 
 func TestVerifyPKCS1v15(t *testing.T) {
 	for i, test := range signPKCS1v15Tests {
-		h := sha1.New()
+		h := sha256.New()
 		h.Write([]byte(test.in))
 		digest := h.Sum(nil)
 
 		sig, _ := hex.DecodeString(test.out)
 
-		err := VerifyPKCS1v15(&boringRsaPrivateKey.PublicKey, crypto.SHA1, digest, sig)
+		err := VerifyPKCS1v15(&boringRsaPrivateKey.PublicKey, crypto.SHA256, digest, sig)
 		if err != nil {
 			t.Errorf("#%d %s", i, err)
 		}
diff --git a/src/crypto/rsa/pss_test.go b/src/crypto/rsa/pss_test.go
index befd1612b5..afa25a737c 100644
--- a/src/crypto/rsa/pss_test.go
+++ b/src/crypto/rsa/pss_test.go
@@ -301,7 +301,7 @@ func fromHex(hexStr string) []byte {
 }
 
 func TestInvalidPSSSaltLength(t *testing.T) {
-	key, err := GenerateKey(rand.Reader, 245)
+	key, err := GenerateKey(rand.Reader, 2048)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/src/crypto/rsa/rsa.go b/src/crypto/rsa/rsa.go
index e6bf6a5e88..577ba1d751 100644
--- a/src/crypto/rsa/rsa.go
+++ b/src/crypto/rsa/rsa.go
@@ -272,6 +272,7 @@ func GenerateKey(random io.Reader, bits int) (*PrivateKey, error) {
 	return GenerateMultiPrimeKey(random, 2, bits)
 }
 
+
 // GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit
 // size and the given random source.
 //
@@ -292,6 +293,24 @@ func GenerateKey(random io.Reader, bits int) (*PrivateKey, error) {
 //
 // [On the Security of Multi-prime RSA]: http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf
 func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey, error) {
+	if boring.Enabled() && boring.IsStrictFIPSMode() && !(random == boring.RandReader && nprimes == 2 &&
+		(bits == 2048 || bits == 3072 || bits == 4096)) {
+		return nil, errors.New("crypto/rsa: invalid primes or bits for boring")
+	}
+	return generateMultiPrimeKeyInternal(random, nprimes, bits)
+}
+
+func GenerateKeyNotBoring(random io.Reader, bits int) (*PrivateKey, error) {
+	boring.UnreachableExceptTests()
+	return generateMultiPrimeKeyInternal(random, 2, bits)
+}
+
+func GenerateMultiPrimeKeyNotBoring(random io.Reader, nprimes int, bits int) (*PrivateKey, error) {
+	boring.UnreachableExceptTests()
+	return generateMultiPrimeKeyInternal(random, nprimes, bits)
+}
+
+func generateMultiPrimeKeyInternal(random io.Reader, nprimes int, bits int) (*PrivateKey, error) {
 	randutil.MaybeReadByte(random)
 
 	if boring.Enabled() && random == boring.RandReader && nprimes == 2 &&
@@ -346,6 +365,7 @@ func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey
 		return key, nil
 	}
 
+
 	priv := new(PrivateKey)
 	priv.E = 65537
 
diff --git a/src/crypto/rsa/rsa_test.go b/src/crypto/rsa/rsa_test.go
index 4b7427e1ae..da8c104044 100644
--- a/src/crypto/rsa/rsa_test.go
+++ b/src/crypto/rsa/rsa_test.go
@@ -26,7 +26,17 @@ import (
 import "crypto/internal/backend/boringtest"
 
 func TestKeyGeneration(t *testing.T) {
-	for _, size := range []int{128, 1024, 2048, 3072} {
+	testKeys := []int{128, 1024}
+	if boring.Enabled() {
+		for _, size := range testKeys {
+			_, err := GenerateKey(rand.Reader, size)
+			if err == nil && boring.IsStrictFIPSMode() {
+				t.Errorf("Gener(%d): boring: bad accept", size)
+			}
+		}
+		testKeys = []int{2048, 3072}
+	}
+	for _, size := range testKeys {
 		priv, err := GenerateKey(rand.Reader, size)
 		if err != nil {
 			t.Errorf("GenerateKey(%d): %v", size, err)
@@ -53,7 +63,12 @@ func Test3PrimeKeyGeneration(t *testing.T) {
 
 	priv, err := GenerateMultiPrimeKey(rand.Reader, 3, size)
 	if err != nil {
+		if boring.IsStrictFIPSMode() {
+			return
+		}
 		t.Errorf("failed to generate key")
+	} else if boring.IsStrictFIPSMode() {
+		t.Errorf("bad accept in strictfipsmode")
 	}
 	testKeyBasics(t, priv)
 }
@@ -66,12 +81,20 @@ func Test4PrimeKeyGeneration(t *testing.T) {
 
 	priv, err := GenerateMultiPrimeKey(rand.Reader, 4, size)
 	if err != nil {
+		if boring.IsStrictFIPSMode() {
+			return
+		}
 		t.Errorf("failed to generate key")
+	} else if boring.IsStrictFIPSMode() {
+		t.Errorf("bad accept in strictfipsmode")
 	}
 	testKeyBasics(t, priv)
 }
 
 func TestNPrimeKeyGeneration(t *testing.T) {
+	if boring.Enabled() {
+		t.Skip("Not supported in boring mode")
+	}
 	primeSize := 64
 	maxN := 24
 	if testing.Short() {
@@ -206,7 +229,7 @@ func TestEverything(t *testing.T) {
 		size := size
 		t.Run(fmt.Sprintf("%d", size), func(t *testing.T) {
 			t.Parallel()
-			priv, err := GenerateKey(rand.Reader, size)
+			priv, err := GenerateKeyNotBoring(rand.Reader, size)
 			if err != nil {
 				t.Errorf("GenerateKey(%d): %v", size, err)
 			}
diff --git a/src/crypto/tls/boring_test.go b/src/crypto/tls/boring_test.go
index 49702f59ba..01d3c35f35 100644
--- a/src/crypto/tls/boring_test.go
+++ b/src/crypto/tls/boring_test.go
@@ -7,6 +7,7 @@
 package tls
 
 import (
+	"crypto"
 	"crypto/ecdsa"
 	"crypto/elliptic"
 	boring "crypto/internal/backend"
@@ -216,7 +217,10 @@ func TestBoringServerSignatureAndHash(t *testing.T) {
 
 			testingOnlyForceClientHelloSignatureAlgorithms = []SignatureScheme{sigHash}
 
-			sigType, _, _ := typeAndHashFromSignatureScheme(sigHash)
+			sigType, hashFunc, _ := typeAndHashFromSignatureScheme(sigHash)
+			if hashFunc == crypto.SHA1 && !boringtest.Supports(t, "SHA1") {
+				t.Skip("unsupported in FIPS mode")
+			}
 			switch sigType {
 			case signaturePKCS1v15, signatureRSAPSS:
 				serverConfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
@@ -329,7 +333,7 @@ func TestBoringCertAlgs(t *testing.T) {
 	// Set up some roots, intermediate CAs, and leaf certs with various algorithms.
 	// X_Y is X signed by Y.
 	R1 := boringCert(t, "R1", boringRSAKey(t, 2048), nil, boringCertCA|boringCertFIPSOK)
-	R2 := boringCert(t, "R2", boringRSAKey(t, 512), nil, boringCertCA)
+	R2 := boringCert(t, "R2", NotBoringRSAKey(t, 2560), nil, boringCertCA)
 
 	M1_R1 := boringCert(t, "M1_R1", boringECDSAKey(t, elliptic.P256()), R1, boringCertCA|boringCertFIPSOK)
 
@@ -353,9 +357,9 @@ func TestBoringCertAlgs(t *testing.T) {
 	// Older versions of OpenSSL allow 1024 bit leaf certs
 	var L2_I *boringCertificate
 	if boringtest.Supports(t, "RSA1024LeafCert") {
-		L2_I = boringCert(t, "L2_I", boringRSAKey(t, 1024), I_R1, boringCertLeaf)
+		L2_I = boringCert(t, "L2_I", NotBoringRSAKey(t, 1024), I_R1, boringCertLeaf)
 	} else {
-		L2_I = boringCert(t, "L2_I", boringRSAKey(t, 1024), I_R1, boringCertLeaf|boringCertNotBoring)
+		L2_I = boringCert(t, "L2_I", NotBoringRSAKey(t, 1024), I_R1, boringCertLeaf|boringCertNotBoring)
 	}
 
 	// client verifying server cert
@@ -515,6 +519,15 @@ const (
 	boringCertNotBoring = 0x100
 )
 
+func NotBoringRSAKey(t *testing.T, size int) *rsa.PrivateKey {
+	k, err := rsa.GenerateKeyNotBoring(rand.Reader, size)
+	if err != nil {
+		t.Fatal(err)
+	}
+	return k
+}
+
+
 func boringRSAKey(t *testing.T, size int) *rsa.PrivateKey {
 	k, err := rsa.GenerateKey(rand.Reader, size)
 	if err != nil {
diff --git a/src/crypto/x509/boring_test.go b/src/crypto/x509/boring_test.go
index 07b3c7095e..38790b33af 100644
--- a/src/crypto/x509/boring_test.go
+++ b/src/crypto/x509/boring_test.go
@@ -27,6 +27,14 @@ const (
 	boringCertFIPSOK = 0x80
 )
 
+func notBoringRSAKey(t *testing.T, size int) *rsa.PrivateKey {
+	k, err := rsa.GenerateKeyNotBoring(rand.Reader, size)
+	if err != nil {
+		t.Fatal(err)
+	}
+	return k
+}
+
 func boringRSAKey(t *testing.T, size int) *rsa.PrivateKey {
 	k, err := rsa.GenerateKey(rand.Reader, size)
 	if err != nil {
@@ -55,7 +63,7 @@ type boringCertificate struct {
 
 func TestBoringAllowCert(t *testing.T) {
 	R1 := testBoringCert(t, "R1", boringRSAKey(t, 2048), nil, boringCertCA|boringCertFIPSOK)
-	R2 := testBoringCert(t, "R2", boringRSAKey(t, 512), nil, boringCertCA)
+	R2 := testBoringCert(t, "R2", notBoringRSAKey(t, 2560), nil, boringCertCA)
 	R3 := testBoringCert(t, "R3", boringRSAKey(t, 4096), nil, boringCertCA|boringCertFIPSOK)
 
 	M1_R1 := testBoringCert(t, "M1_R1", boringECDSAKey(t, elliptic.P256()), R1, boringCertCA|boringCertFIPSOK)
@@ -78,7 +86,7 @@ func TestBoringAllowCert(t *testing.T) {
 	testBoringCert(t, "I_R3", I_R3.key, R3, boringCertCA|boringCertFIPSOK)
 
 	testBoringCert(t, "L1_I", boringECDSAKey(t, elliptic.P384()), I_R1, boringCertLeaf|boringCertFIPSOK)
-	testBoringCert(t, "L2_I", boringRSAKey(t, 1024), I_R1, boringCertLeaf)
+	testBoringCert(t, "L2_I", notBoringRSAKey(t, 1024), I_R1, boringCertLeaf)
 }
 
 func testBoringCert(t *testing.T, name string, key interface{}, parent *boringCertificate, mode int) *boringCertificate {
diff --git a/src/crypto/x509/verify_test.go b/src/crypto/x509/verify_test.go
index 3551b470ce..6f9573d066 100644
--- a/src/crypto/x509/verify_test.go
+++ b/src/crypto/x509/verify_test.go
@@ -8,6 +8,7 @@ import (
 	"crypto"
 	"crypto/ecdsa"
 	"crypto/elliptic"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"crypto/x509/pkix"
 	"encoding/asn1"
@@ -37,6 +38,8 @@ type verifyTest struct {
 
 	errorCallback  func(*testing.T, error)
 	expectedChains [][]string
+
+	boringSkip bool
 }
 
 var verifyTests = []verifyTest{
@@ -143,6 +146,7 @@ var verifyTests = []verifyTest{
 		// The StartCom root is not trusted by Windows when the default
 		// ServerAuth EKU is requested.
 		systemSkip: true,
+		boringSkip: true,
 
 		expectedChains: [][]string{
 			{"dnssec-exp", "StartCom Class 1", "StartCom Certification Authority"},
@@ -155,6 +159,7 @@ var verifyTests = []verifyTest{
 		roots:         []string{startComRoot},
 		currentTime:   1302726541,
 		keyUsages:     []ExtKeyUsage{ExtKeyUsageAny},
+		boringSkip:    true,
 
 		expectedChains: [][]string{
 			{"dnssec-exp", "StartCom Class 1", "StartCom Certification Authority"},
@@ -167,6 +172,7 @@ var verifyTests = []verifyTest{
 		roots:         []string{startComRoot},
 		currentTime:   1302726541,
 		systemSkip:    true, // see dnssec-exp test
+		boringSkip:    true,
 
 		expectedChains: [][]string{
 			{"dnssec-exp", "StartCom Class 1", "StartCom Certification Authority"},
@@ -228,6 +234,7 @@ var verifyTests = []verifyTest{
 		roots:         []string{globalSignRoot},
 		currentTime:   1382387896,
 		dnsName:       "secure.iddl.vt.edu",
+		boringSkip:    true,
 
 		expectedChains: [][]string{
 			{
@@ -557,6 +564,9 @@ func TestGoVerify(t *testing.T) {
 
 	for _, test := range verifyTests {
 		t.Run(test.name, func(t *testing.T) {
+			if test.boringSkip && boring.Enabled() {
+				t.Skip("skipping test with BoringCrypto")
+			}
 			testVerify(t, test, false)
 		})
 	}
diff --git a/src/crypto/x509/x509_test.go b/src/crypto/x509/x509_test.go
index e01c24292e..356528e69c 100644
--- a/src/crypto/x509/x509_test.go
+++ b/src/crypto/x509/x509_test.go
@@ -3001,7 +3001,7 @@ func TestUnknownExtKey(t *testing.T) {
 		DNSNames:     []string{"foo"},
 		ExtKeyUsage:  []ExtKeyUsage{ExtKeyUsage(-1)},
 	}
-	signer, err := rsa.GenerateKey(rand.Reader, 1024)
+	signer, err := rsa.GenerateKey(rand.Reader, 2048)
 	if err != nil {
 		t.Errorf("failed to generate key for TestUnknownExtKey")
 	}
@@ -3164,7 +3164,7 @@ func TestCreateCertificateBrokenSigner(t *testing.T) {
 		SerialNumber: big.NewInt(10),
 		DNSNames:     []string{"example.com"},
 	}
-	k, err := rsa.GenerateKey(rand.Reader, 1024)
+	k, err := rsa.GenerateKey(rand.Reader, 2048)
 	if err != nil {
 		t.Fatalf("failed to generate test key: %s", err)
 	}
@@ -3637,6 +3637,9 @@ func TestParseUniqueID(t *testing.T) {
 }
 
 func TestDisableSHA1ForCertOnly(t *testing.T) {
+	if boring.Enabled() && !boringtest.Supports(t, "SHA1") {
+		t.Skip("unsupported in FIPS mode")
+	}
 	t.Setenv("GODEBUG", "")
 
 	tmpl := &Certificate{
diff --git a/src/crypto/x509/x509_test_import.go b/src/crypto/x509/x509_test_import.go
index 2474e3d810..492cb0a875 100644
--- a/src/crypto/x509/x509_test_import.go
+++ b/src/crypto/x509/x509_test_import.go
@@ -42,14 +42,38 @@ func main() {
 	}
 }
 
-var pemPrivateKey = testingKey(`-----BEGIN RSA TESTING KEY-----
-MIIBOgIBAAJBALKZD0nEffqM1ACuak0bijtqE2QrI/KLADv7l3kK3ppMyCuLKoF0
-fd7Ai2KW5ToIwzFofvJcS/STa6HA5gQenRUCAwEAAQJBAIq9amn00aS0h/CrjXqu
-/ThglAXJmZhOMPVn4eiu7/ROixi9sex436MaVeMqSNf7Ex9a8fRNfWss7Sqd9eWu
-RTUCIQDasvGASLqmjeffBNLTXV2A5g4t+kLVCpsEIZAycV5GswIhANEPLmax0ME/
-EO+ZJ79TJKN5yiGBRsv5yvx5UiHxajEXAiAhAol5N4EUyq6I9w1rYdhPMGpLfk7A
-IU2snfRJ6Nq2CQIgFrPsWRCkV+gOYcajD17rEqmuLrdIRexpg8N1DOSXoJ8CIGlS
-tAboUGBxTDq3ZroNism3DaMIbKPyYrAqhKov1h5V
+// This key is generated with the following command:
+//
+//   openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out key.pem
+//   openssl pkey -traditional -in key.pem > key-traditional.pem
+//
+var pemPrivateKey = testingKey(`
+-----BEGIN RSA TESTING KEY-----
+MIIEogIBAAKCAQEAp5qgUIj096pw8U+AjcJucLWenR3oe+tEthXiAuqcYgslW5UU
+lMim34U/h7NbLvbG2KJ2chUsmLtuCFaoIe/YKW5DKm3SPytK/KCBsVa+MQ7zuF/1
+ks5p7yBqFBl6QTekMzwskt/zyDIG9f3A+38akruHNBvUgYqwbWPx4ycclQ52GSev
+/Cfx0I68TGT5SwN/eCJ/ghq3iGAf0mX1bkVaW1seKbL49aAA94KnDCRdl813+S2R
+EPDf2tZwlT0JpZm5QtAqthonZjkjHocZNxhkKF3XWUntE/+l6R4A+CWZlC2vmUc1
+hJTEraksy2JUIjxAaq//FnDpIEVG/N2ofmNpaQIDAQABAoIBAAYH7h9fwkLcNvqz
+8+oF9k/ndSjtr9UvstYDhRG6S/zKLmK0g1xUOQ7/fjj9lvkiZ6bZd74krWlkizHR
+HnU0KnjZLyEKeR+NSQI8q1YMi0T8JwB6MX3CIDU62x5UiV3p6OZwEqGJXf4U8MOu
+ySAzo2rmxRd2reeobC9Pgp98I47oeqaSRwFVZRPfKk5RvfI7KRmL58BAB0XS56PA
+PJ+3l0fB/oIV11iaBEKildxLDtrvlepQ2KPNf7Dpk0/CPRtS/jxyxIyML8tjR3F0
+KuHplsRjTANyzW/aHddO1fnfnXsVo+0PzSPTHCbxKSu5XmChqsKoB1jM+/tJci4y
+ST5hUXUCgYEAzfA5XEMkR/NNJMfR+FBbdfpQ1b0wqH3qtWZx/tBjKC2Y0XnDQ8ZR
+SEWONLVZMRtTlJaHIPZ9i6anQRR5harrff0OpsKiJUGDout8ehE6eiN8ABWGNlCI
+AiLCerVJZMDcSuDU7xsdHVIdSxYh88Z9g54vUQ4214BG/G0Qm1emV3UCgYEA0FjP
+wq5cEGt9xDCg+oXk0bLm4Wn4FkabJH7M+oCosHHY9W1vgvv50bpNoAbaB5r1mlan
+T6gEtkQPB2juMTnuIwRL+kvOmSKqZGlAsyrq8smTuBUv7brbybkYN3Rg51KV6u1J
+vCdGpMYWHUNRkkQ88cr6iFPodYU+CzRR4ABif6UCgYBc0jDYb/7TW0tjD5mJJZcD
+xw5WOE7NMuvuVT1+T6jRvDOL/yjOzH1oaMle4npQEvQKHgrMBa2ymyv5vmPDprU7
+9Sp8aW+yASR281MIpelIkePbGdiDdKrI46fqrPlmqzLfoRT4rKzjwVYouNIW0VlT
+UKIdE54OZegY8IOysL/t3QKBgDZnSnECiIW9G80UCaUBO3vKZGFuA1sFutMvzSSI
+XgQc5lNH7TtdwqESLdzgjSQ5QXK4t92j+P8DDI2Zx8DQ6K76G0DTdLImDCpGFZ/z
+UABvxIPn/GjuRyAIlhs852Tf+seqiHt6Igc6tmGTx4QTD3rvzrW0e1ncnhPc6Jg+
+YXoFAoGARD9OPrd4J2N+nkSWif9VOuPHvOXEczwBDJbsAGrOW1kTbDStF0OIVOt0
+Ukj+mnnL8ZNyVLgTrZDRfXvlA94EbPK5/rMAYwjMlXHP8R22ts3eDMNUdw0/Zl1g
+QOhL8wXZcdwHKsONy55kZHo8pmneqi9EnqqLGguLwx5WIMzWvZ8=
 -----END RSA TESTING KEY-----
 `)
 
